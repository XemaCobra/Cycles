Make a request
----

You can retrieve the content of a URL through Cycles's methods in a asynchronous manner:
```
Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    println("\(cycle.response.text)") // [{"created_at":"2014-06...
});
```
The response can be handled in the `completionHandler` closure. The `cycle` argument contains all the information on both request and response.

Besides "GET" method, you can send requests with other HTTP in similar ways.

```
Cycle.post("http://httpbin.org/post", completionHandler: {
    (cycle, error) in
});

Cycle.put("http://httpbin.org/put", completionHandler: {
    (cycle, error) in
});

Cycle.delete("http://httpbin.org/delete", completionHandler: {
    (cycle, error) in
});

Cycle.delete("http://httpbin.org/delete", completionHandler: {
    (cycle, error) in
});

Cycle.head("http://httpbin.org/get", completionHandler: {
    (cycle, error) in
});
```

`completionHandler` isn't optional, because otherwise you will have no way to obtain data from response.



Architecture
----

The `Cycle` object
~~~~
A `Cycle` object (instance of class `Cycle`) represents both HTTP request and HTTP response. To send a request, a `Cycle` object will be created and initialized. To retrieve the response content, you examine the same `Cycle` object.

A `Cycle` object holds all the information on request and retrieved response. You can resend a request by invoking a single method on an existing `Cycle` object, even if it has been "used".


Thin wrappers
~~~~
Some of the Cycles classes are thin wrappers around the NSURLSession classes. These Cycles classes all have a property called `core` which points to the underlying Cocoa object. Here is a table on the relationships:

============  ===================
Cycles Class  Cocoa Class
============  ===================
Cycle         NSURLSessionTask
Request       NSMutableURLRequest
Response      NSHTTPURLResponse
Session       NSURLSession
============  ===================


Diagram
~~~~

      +------------------------------------+
      |                                    |
      |   +-----------+    +-----------+   |
      |   |           |    |           |   |
      |   |  Request  |    | Response? |   |
      |   +-----------+    +-----------+   |
      |                                    |
      |   Cycle                            |
      |                                    |
      +------------------------------------+
                         |
                         |
                   +-----------+
                   |           |
                   |  Session  |
                   +-----------+




Get the code
----
Cycles is open source, and the code is "available on github"_. There is no demo project for now, files for Cycles can be found in the "source folder"_.

.. _"available on github": https://github.com/weipin/Cycles
.. _"source folder": https://github.com/weipin/Cycles/tree/master/source

Install manually
----
Cycles hasn't been packaged as a framework for now. You will have to add the source files to your own project to use Cycles.

- Except the Objective-C files (Utils.h and Utils.m), add all files in the "source" folder to your project.
- Add Objective-C files (Utils.h and Utils.m) to your project. If Xcode asks if you want to configure an Objective-C bridging header, select Yes. If Xcode keeps crashing, try copy the files to your project's folder and then add.
- In the bridging header file Xcode created for you (filename like PROJECT-Bridging-Header.h), import the Objective-C header files.
```
#import "Utils.h"
```

- Quickstart
  - Make requests through convenient methods
----

The convenient methods can create a `Cycle` object for you and send the request through that object immediately. For example, to send a GET request, use the "type method"_ `class func get(URLString: String, parameters: Dictionary<String, String[]>? = nil, requestProcessors: Processor[]? = nil, responseProcessors: Processor[]? = nil, authentications: Authentication[]? = nil, solicited: Bool = false, completionHandler: CycleCompletionHandler) -> Cycle` of `Cycle`

```
Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    println("\(cycle.response.text)") // [{"created_at":"2014-06...
});
```

There are type methods for the other request types like POST, PUT, DELETE, etc. See "Cycle+Convenience.swift"_ for a complete list.

The convenient methods provide only limited customization of networking behavior. And the request will be sent immediately. If you have needs beyond basic URL fetching, such as custom headers, or want to delay sending the request, you can make requests in two separate steps. See the next section for more information.

.. _"type method": https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-XID_307
.. _"Cycle+Convenience.swift": https://github.com/weipin/Cycles/blob/master/source/Cycle%2BConvenience.swift

  - Make requests through 2 steps
----

The two steps are:
- Create and configure a `Cycle` object.
- "Start" the `Cycle` object.

Creating a `Cycle` object is simple, the only required parameter is `requestURL`.
```
var URL = NSURL(string: "https://github.com/timeline.json")
var cycle = Cycle(requestURL: URL)
```

There are other parameters, such as `parameters`, which will be discussed in the following sections.

To send the HTTP request, call the method `func start(completionHandler: CycleCompletionHandler? = nil)` of `Cycle`.
```
cycle.start(completionHandler: {(cycle, error) in
    // handle response
})
```
You can handle the response in the `completionHandler` closure. Because `completionHandler` is the last parameter, the code can be simplified with Trailing Closures expression.
```
cycle.start {(cycle, error) in
  // handle response
}
```

You can examine the optional parameter `error` to see if the content is fetched successfully. The error can be caused by HTTP connection, Processor objects, HTTP status code, etc. For more information on error handling, see :ref:`error`


.. :ref:`error`

POST raw data
----
You can post raw data through both approaches: 1) the convenient method of `Cycle`. 2) create, configure a `Cycle` object and then "start".

Here is an example of using the convenient method:
```
Cycle.post("http://127.0.0.1:8000/test/dumpupload/",
    requestObject: "Hello World".dataUsingEncoding(NSUTF8StringEncoding),
    requestProcessors: [DataProcessor()],
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // Hello World
    })
```

In this code snippet, a NSData is past as parameter `requestObject` and a `DataProcessor` is created and passed as `requestProcessors` in an array. The relationship between `requestObject` and `requestProcessors` will be explained in :ref:send_request_with_processors, :ref:receive_response_with_processors and :ref:the_object_property.

Here is an example of creating the `Cycle` manually. You create the `Cycle` and assign the NSData to the property `data` of the Request, which is property `request` of the `Cycle`.
```
var URL = NSURL(string: "http://127.0.0.1:8000/test/dumpupload/")
var cycle = Cycle(requestURL: URL, requestMethod: "POST")
cycle.request.data = "Hello World".dataUsingEncoding(NSUTF8StringEncoding)
cycle.start {
    (cycle, error) in
    println("\(cycle.response.text)") // Hello World
}
```

.. :ref:`error`
.. :ref:`receive_response_with_processors`
.. :ref:`the_object_property`


Custom headers
----
The convenient methods do not support custom headers. You have to create a `Cycle` to add headers.

```
var URL = NSURL(string: "https://github.com/timeline.json")
var cycle = Cycle(requestURL: URL)
cycle.request.core.setValue("Cycles/0.01", forHTTPHeaderField: "User-Agent")
```



  - Cancellation
-----
To cancel a request, you need the `Cycle` object the request attached to. If the request is issued by a convenient method, you need to store the `Cycle` object returned from that convenient method.
```
var cycle = Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    // ...
});
```

Call the method `func cancel(explicitly: Bool)` of `Cycle` to cancel the request. The parameter `explicitly` indicates if the request is cancelled explicitly. `explicitly` does not affect how the connection will be cancelled, but merely a value to be stored in the property `explicitlyCanceling` of `Cycle`. Your app can use this value for cancellation logic -- when the connection is cancelled, the `completionHandler` won't be called if `explicitly` is set as `true`. You probably want to pass `true` as `explicitly`, to address the cases that users cancelled an operation explicitly. If you pass `false`, you can examine the argument `error` of `completionHandler` to see if the connection is cancelled, here is an example.
```
cycle.start(completionHandler: {(cycle, error) in
    if let e = error {
        if e.domain == NSURLErrorDomain && e.code == NSURLErrorCancelled {
            // Process cancellation
        }
    }
})
```

  - Add parameters to URL
To add parameters (query) to URL, pass a dictionary as `parameters` to the convenient methods. The code snippet below adds parameter "key1=value1" to the URL -- the URL becomes "http://httpbin.org/get?key1=value1".

```
Cycle.get("http://httpbin.org/get",
        parameters: ["key1": ["value1"]],
        completionHandler: {cycle, error in
            println("\(cycle.response.text)")
    })
```

The type of `parameter` is `Dictionary<String, String[]>`, the type of the key is `String`, the type of the value is an array of `String`. While in most cases, you will use the array to hold one single value, it allow multiple values to be associated with a single key. The final URL produced by the code below is "http://httpbin.org/get?key1=value1&key1=value1a".

```
Cycle.get("http://httpbin.org/get",
        parameters: ["key1": ["value1", "value1a"]],
        completionHandler: {cycle, error in
            println("\(cycle.response.text)")
    })
```

There is no such `parameters` when you create a `Cycle` by yourself. It's very simple to build a URL from the parameters through the helper methods provided by Cycles.

```
// result: http://httpbin.org/get?key1=value1
var URLString = MergeParametersToURL("http://httpbin.org/get", ["key1": ["value1"]])
```

The function `MergeParametersToURL` will correctly encode the values, join the parameter pairs with character `&` and join the original URL with character `?`.  `MergeParametersToURL` also allows query string in the original URL, the method will parse the query and merge them with the parameters. In the code snippet below, `key2` in the original URL and `key1` in the parameter will both appear in the final URL.

```
// result: http://httpbin.org/get?key1=value1&key2=value2
var URLString = MergeParametersToURL("http://httpbin.org/get?key2=value2", ["key1": ["value1"]])
```

- Response status code
----
Once a Cycle successfully retrieved content, you can check the response status code through the property `statusCode` of Response.
```
cycle.response.statusCode
```

`statusCode` is a "Computed Property"_ which obtains the value from a `NSHTTPURLResponse`.

.. _"computed properties": https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-XID_329

- Response headers
Once a Cycle successfully retrieved content, you can check the response headers through the property `headers` of Response.
```
var value = cycle.response.headers!.objectForKey("Content-Type") as String
println("\(value)") // application/json
```

`headers` is a "Computed Property"_ which obtains the value from a `NSHTTPURLResponse`. The value is a NSDictionary.

The code above has two problems:
- It's unnecessary complicated, even if it already ignored the error handling.
- Fetching a header like this isn't case-insensitive.

The ideal way to obtain a header is through method `valueForHTTPHeaderField` of Response. Accessing a header through `valueForHTTPHeaderField` is case-insensitive and the syntax is simpler.
```
if let value = cycle.response.valueForHTTPHeaderField("content-type") {
    println("\(value)")
}
```

- Response error
To check if there is any error happens, examine the argument `error` of `completionHandler`. The error can be caused by network connection (NSURLErrorDomain) or the Cycles objects (CycleErrorDomain) or other reasons.

- Response content
Once a Cycle successfully retrieved content, you can obtain the response content through property `text` of Response.
```
println("\(cycle.response.text)") // Hello World
```

Property `text` is a `String` which will be created from response data (property `data` of Response, a NSData). To properly create the String, the Response have to obtain the encoding of the content. The Response will try to find a encoding through the HTTP headers first, if not find, response data will be looked through to guess the encoding. There is one exception, if there is no charset in headers and the Content-Type contains "text", the encoding will be defaults to "ISO-8859-1", according to RFC 2616, 3.7.1.


- Upload
Uploading a NSData or a file is easy through the upload convenient methods.

Upload a NSData
```
Cycle.upload("http://127.0.0.1:8000/test/dumpupload/",
    data: "Hello World".dataUsingEncoding(NSUTF8StringEncoding),
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // Hello World
    })
```

Upload a file
```
Cycle.upload("http://127.0.0.1:8000/test/dumpupload/",
    file: NSURL(string: "/PATH/TO/FILE"),
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // content of file
    })
```

To obtain upload progress information, pass a `CycleDidSendBodyDataHandler` as parameter `didSendBodyDataHandler`.
```
Cycle.upload("http://127.0.0.1:8000/test/dumpupload/",
    file: NSURL(string: ""),
    didSendBodyDataHandler: {
        (cycle, bytesSent, totalBytesSent, totalBytesExpectedToSend) in
        // handle progress
    },
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // Hello World
    })
```

- Download

Downloading a file is easy through the download convenient methods. Background download isn't support for now.

```
var URLString = "http://127.0.0.1:8000/test/echo?content=helloworld"
Cycle.download(URLString,
    downloadFileHandler: {(cycle, location) in
        var content = NSString(contentsOfURL: location, encoding: NSUTF8StringEncoding, error: nil)
        println("\(content)") // helloworld
    },
    completionHandler: {(cycle, error) in
      // check error
    })
```

The closure `downloadFileHandler` will be called with the URL (`location`) to a temporary file where the downloaded content is stored. At the time `downloadFileHandler` is called, you are guaranteed that the content has been fetched successfully. Put your error handling code in `completionHandler`.

- Send JSON request
----
It's common to send request with JSON content. To POST such requests through convenient methods, you need to do two things:
- Prepare a collection object (a NSDictionary in most cases) and pass the object as parameter `requestObject`.
- Create a JSONProcessor, put it into an array and pass the array as parameter `requestProcessors`.

```
Cycle.post("http://127.0.0.1:8000/test/dumpupload/",
    requestObject: NSDictionary(object: "v1", forKey: "k1"),
    requestProcessors: [JSONProcessor()],
    completionHandler: {(cycle, error) in
    })
```

Cycles will convert the NSDictionary into a NSData with JSON format through the JSONProcessor and assign the NSData to the property `data` of Request. The JSONProcessor will also set header "Content-Type" as "application/json".

- Send request with processors
----
Before a request can be sent, there may be extra preparation work. Take "Send a JSON request" as an example, following tasks need to be taken care of:
- Create a NSData with JSON format from a collection object.
- Assign the NSData to the property `data` of Request.
- Set header "Content-Type" as "application/json".

With Cycles, you can use Processor objects to complete such tasks. Each subclass of Processor can handle a certain type of object and prepare the Request for you. A `Cycle` accepts an array of Processor objects as property `requestProcessors`. Before a request is being sent, each Processor object in the requestProcessors will be given an oppotunity to process the Request.

- Receive JSON response
For JSON responses, you will want to convert the data back into a collection object. You can ask Cycles do the job for your by create a JSONProcessor, put it into an array and pass the array as parameter `requestProcessors`.

```
Cycle.post("http://127.0.0.1:8000/test/dumpupload/",
    requestObject: NSDictionary(object: "v1", forKey: "k1"),
    requestProcessors: [JSONProcessor()],
    completionHandler: {(cycle, error) in
    })
```

Cycles will convert the response data into a collection object through the JSONProcessor and assign the object to the property `object` of Response.

- Receive response with processors

Like requests, responses may also need some extra work before your app can use the content. Take "Receive JSON response" as an example, following tasks need to be taken care of:
- Create a collection object from response content with JSON format.
- Assign the collection object to the property `object` of Response.

With Cycles, you can also use Processor objects to complete such tasks. Each subclass of Processor can handle a certain type of response content and prepare the Response for you. A `Cycle` accepts an array of Processor objects as property `responseProcessors`. After a response is received, each Processor object in the requestProcessors will be given an oppotunity to process the Response.

- Create your own processors

You can create your own processors to fit your requirements. For example, you can create a Processor subclass to handle specific authentication types (add certain headers to request). Or, you can create a Processor subclass to process response content with a specific format.

To create your own processors, you subclass `Processor`. There are two method to override, `func processRequest(request: Request, error: NSErrorPointer) -> Bool` and `func processResponse(response: Response, error: NSErrorPointer) -> Bool`. You don't have to override both if one of the method will never going to be used.

- The relationship between property `object` and property `data`
  Both `Request` and `Response` have property `object` and property `data`.

  The property `object` represents a model object, depends on your requirement, it can be any type. For `Request`, the `object` will be used to create request data. For `Response`, the `object` will be used to store the model converted from response content.

  The property `data` represents the raw data, the type is NSData. For `Request`, the `object` is the request body to send. For `Response`, the `object` is the response content received.

  The conversion between `object` and `data` is performed by the Processor objects. For `Request`, the Processors will convert the `object` into `data`. For `Response`, the Processors will convert the `data` into `object`.

- Auto retry
Cycles will retry a request if one of the following conditions match.
- The connection timed out.
- The response status code is 408 or 503.

Cycles will stop retrying if the retried number exceed the limit. The limit is controlled by the property `RetryPolicyMaximumRetryCount` of Session. There is one exception, if the property `solicited` of `Cycle` is true,
Cycles will keep trying for any error until it receives the content.

- Timeout
You probably don't need to worry about the timeout because Cycles will retry a request for you. If you have a need for a custom timeout period, you can create a NSURLSessionConfiguration, set the property `timeoutIntervalForRequest` and `timeoutIntervalForResource`, create a Session from this NSURLSessionConfiguration and use this session to create a `Cycle`. The code snippet below set the timeout to a unrealistic value of 1.0 second. This is the same code used in one of the tests.

```
var configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.timeoutIntervalForRequest = 1;
configuration.timeoutIntervalForResource = 1
var session = Session(configuration: configuration)

var URL = NSURL(string: "http://127.0.0.1:8000/test/echo?delay=2")
var cycle = Cycle(requestURL: URL, session: session)
cycle.start {(cycle, error) in
  ...
}
```

- Solicited request
  Solicited and unsolicited is more of an user interface concept. A solicited request is an operation specifically issued by the user, like tapping a button to reload a list. In such case, if there is any error happens while fetching the content, it's ideal for your app to keep retrying until it succeeds. The solicited state is represented by the property `solicited` of `Cycle`. If the value of `solicited` is true, Cycles will keep retrying the request until it receives the content.

  Most of the convenient methods accept a parameter for `solicited`, which will be assigned to the `Cycle`.

- Session
  Each `Cycle` references to a `Session`, which does all the heavy lifting. Class `Session` is a thin wrapper around class `NSURLSession`.

- The default session
  If you don't pass a `Session` when you create a `Cycle`, a default `Session` will be used. The default `Session` is a singleton returned by the type method `defaultSession` of `Session`. If you change a property of this `Session`, all the `Cycle` objects referencing this object may be affected.

- Provide `Cycle` properties through Session
  Sometimes you need to assign certain properties to multiple `Cycle` objects with same values. `Cycles` offers a way to make this task easier. For some of these properties, you can assign the values to the Session and leaves the corresponding properties of `Cycle` objects as nil. For these `Cycle` objects, the Session objects they reference to will be used to return these values.

  For example, if you see an array of Processor as property `requestProcessors` to a Session, all the `Cycle` objects reference to this Session object will return this array as the value of property `requestProcessors`, as long as the property `requestProcessors` of the `Cycle` object is nil.

Here is a list of the properties that a Session can provide to a `Cycle` objects.

1. `requestProcessors`
1. `responseProcessors`
1. `authentications`



- Create and use your own Session objects
  You may want to create your own Session objects so the `Cycle` objects can reference to the different ones. Creating a Session is easy, the parameters of the initizlizer are all optional.
```
var session = Session()
```

You may want to create and configure a NSURLSessionConfiguration, and pass this NSURLSessionConfiguration as parameter `configuration`.
```
var configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
var session = Session(configuration: configuration)
```

The other two parameters `delegateQueue` and `workerQueue` will be discussed in the next section.

- Operation queues
  A `Session` object has two queues. The `delegateQueue` is for scheduling the handlers, which include all of the `Cycle` handlers  like the `completionHandler`. The default value of `delegateQueue` is the main queue. The `workerQueue` is for scheduling tasks that may require some time to finish. Executing Processor objects will be scheduled in the `workerQueue`. The default value of the `workerQueue` is a new NSOperationQueue, so tasks will be executed off the main thread.

The `delegateQueue` of `Session` will also be passed as `queue` to create a NSURLSession object, so this `delegateQueue` will also be the queue for scheduling NSURLSession's delegate calls and completion handlers. One difference is that for NSURLSession's `queue`, if nil, a serial operation queue will be created and handlers will be called off the main thread. Because it's common to execute user interface code in the handlers, use main queue as the default value can be convenient.


- Authentication
There are two approaches for handing authentication. One is provided by the URL loading system through classes like `NSURLCredential`, `NSURLProtectionSpace`, `NSURLAuthenticationChallenge`, etc. The other is to prepare the request manually or through Processor objects .

Authentication through URL loading system
----
To add authentication support through URL loading system, you can create an object of Authentication subclass, like BasicAuthentication. And add this Authentication object in an array and pass it to the convenient menthod as parameter `authentications`, or assign the array to property `authentications` if you create the `Cycle` manually.

```
var auth = BasicAuthentication(username: "test", password: "12345")
Cycle.get("http://127.0.0.1:8000/test/hello_with_basic_auth",
    authentications: [auth],
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // Hello World
    })
```

The BasicAuthentication object can handle three authentication methods: Basic, Digest and NTLM.


Prepare request manually for authentication
----
There are authentication methods the Authentication classes don't support. And in some situations, preparing requests manually is the only option. Take GitHub API's Basic Authentication as an example, for unauthenticated requests, the GitHub API responds with `404 Not Found`, instead of `401 Unauthorized`. In such case, URL loading system's authentication routes won't be triggered.

The solution is to manually craft the `Authorization` header, and a Processor object is a perfect choice for this task.

```
Cycle.get("https://api.github.com/user/",
    requestProcessors: [BasicAuthProcessor(username: "user", password: "pass")],
    responseProcessors: [JSONProcessor()],
    completionHandler: { (cycle, error) in
        println("\(cycle.response.statusCode)") // 200
        var header = cycle.response.valueForHTTPHeaderField("content-type")
        println("\(header)") // application/json; charset=utf-8
        println("\(cycle.response.textEncoding)") // 4
        println("\(cycle.response.text)") // {"login":"user","id":3 ...
        println("\(cycle.response.object)") // {"avatar_url" = ...
    })
```

In this code snippet, a BasicAuthProcessor object was created and passed into the convenient method as parameter `requestProcessors`. Before the request is sent, the BasicAuthProcessor object will craft and set the `Authorization` header.

- Restart
It's easy to "restart" a Cycle because the object holds enough information to send a request. "Restart" means Cycles will cancel the request first if necessary and then resend it. The ability to restart a request can be very helpful in various situations. For example, if a request failed with an authentication problem like incorrect key token, you can retain the `Cycle` somewhere and display an user interface so the user can solve the authentication problem. Once finished, the `Cycle` can be picked up and restart to continue the previous action.

- Tests
Cycles has its own backend built with Django_ for tests. The backend files can be found in the "backend folder"_. If you want to run the tests on your environment, you need to setup a Django environment and start the backend instance.

Setup the Django environment
----
Assume virtualenv_ is installed.

Prepare the environment.
```
cd backend
virtualenv ~/ENV/cycles
source ~/ENV/cycles/bin/activate
pip install -r requirements.txt
```

Run the backend instance.
```
python manage.py runserver
```

Run the tests
----
In the CyclesTouch folder, open CyclesTouch.xcodeproj with Xcode 6.0. Choose Test from the Project menu.


.. _Django: https://www.djangoproject.com/
.. _"backend folder": https://github.com/weipin/Cycles/tree/master/backend
.. _virtualenv: http://virtualenv.readthedocs.org/en/latest/virtualenv.html
