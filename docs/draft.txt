- Introduction
  - Make a request
  - Architecture
    - The `Cycle` object
    - Thin wrapper
- Installation
  - Get the code
  - Install manually
- Quickstart
  - Make requests through convenient methods
  - Make requests through 2 steps
  - Cancellation
  - Add parameters to URL
  - Response content
  - Response status
  - Response error
  - Upload
  - Download
  - Handle JSON response
  - Handle response with processors
  - Send JSON request
  - Send request with processors
  - Receive response with processors
  - The `object` property of Request and Response
  - Auto retry
  - Custom headers
  - Timeout
  - Solicited request
- Advanced
  - The default session
  - Create and use your own session
  - Delegate queues
  - Authentication
  - Restart
  - Tests
  

Make a request
----

You can retrieve the content of a URL through Cycles's methods in a asynchronous manner:
```
Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    println("\(cycle.response.text)") // [{"created_at":"2014-06...
});
```
The response can be handled in the `completionHandler` closure. The `cycle` argument contains all the information on both request and response.

Besides "GET" method, you can send requests with other HTTP in similar ways.

```
Cycle.post("http://httpbin.org/post", completionHandler: {
    (cycle, error) in
});

Cycle.put("http://httpbin.org/put", completionHandler: {
    (cycle, error) in
});

Cycle.delete("http://httpbin.org/delete", completionHandler: {
    (cycle, error) in
});

Cycle.delete("http://httpbin.org/delete", completionHandler: {
    (cycle, error) in
});

Cycle.head("http://httpbin.org/get", completionHandler: {
    (cycle, error) in
});
```

`completionHandler` isn't optional, because otherwise you will have no way to obtain data from response.



Architecture
----

The `Cycle` object
~~~~
A `Cycle` object (instance of class `Cycle`) represents both HTTP request and HTTP response. To send a request, a `Cycle` object will be created and initialized. To retrieve the response content, you examine the same `Cycle` object.

A `Cycle` object holds all the information on request and retrieved response. You can resend a request by invoking a single method on an existing `Cycle` object, even if it has been "used".


Thin wrapper
~~~~
Some of the Cycles classes are thin wrappers around the NSURLSession classes. These Cycles classes all have a property called `core` which points to the underlying Cocoa object. Here is a table on the relationships:

============  ===================
Cycles Class  Cocoa Class
============  ===================
Cycle         NSURLSessionTask
Request       NSMutableURLRequest
Response      NSHTTPURLResponse
Session       NSURLSession
============  ===================


Diagram
~~~~

      +------------------------------------+
      |                                    |
      |   +-----------+    +-----------+   |
      |   |           |    |           |   |
      |   |  Request  |    | Response? |   |
      |   +-----------+    +-----------+   |
      |                                    |
      |   Cycle                            |
      |                                    |
      +------------------------------------+
                         |
                         |
                   +-----------+
                   |           |
                   |  Session  |
                   +-----------+




Get the code
----
Cycles is open source, and the code is "available on github"_. There is no demo project for now, files for Cycles can be found in the "source folder"_.

.. _"available on github": https://github.com/weipin/Cycles
.. _"source folder": https://github.com/weipin/Cycles/tree/master/source

Install manually
----
Cycles hasn't been packaged as a framework for now. You will have to add the source files to your own project to use Cycles.

- Except the Objective-C files (Utils.h and Utils.m), add all files in the "source" folder to your project.
- Add Objective-C files (Utils.h and Utils.m) to your project. If Xcode asks if you want to configure an Objective-C bridging header, select Yes. If Xcode keeps crashing, try copy the files to your project's folder and then add.
- In the bridging header file Xcode created for you (filename like PROJECT-Bridging-Header.h), import the Objective-C header files.
```
#import "Utils.h"
```

- Quickstart
  - Make requests through convenient methods
----

The convenient methods can create a `Cycle` object for you and send the request through that object immediately. For example, to send a GET request, use the "type method"_ `class func get(URLString: String, parameters: Dictionary<String, String[]>? = nil, requestProcessors: Processor[]? = nil, responseProcessors: Processor[]? = nil, authentications: Authentication[]? = nil, solicited: Bool = false, completionHandler: CycleCompletionHandler) -> Cycle` of `Cycle`

```
Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    println("\(cycle.response.text)") // [{"created_at":"2014-06...
});
```

There are type methods for the other request types like POST, PUT, DELETE, etc. See "Cycle+Convenience.swift"_ for a complete list.

The convenient methods provide only limited customization of networking behavior. And the request will be sent immediately. If you have needs beyond basic URL fetching, such as custom headers, or want to delay sending the request, you can make requests in two separate steps. See the next section for more information.

.. _"type method": https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-XID_307
.. _"Cycle+Convenience.swift": https://github.com/weipin/Cycles/blob/master/source/Cycle%2BConvenience.swift

  - Make requests through 2 steps
----

The two steps are: 
- Create and configure a `Cycle` object.
- "Start" the `Cycle` object.

Creating a `Cycle` object is simple, the only required parameter is `requestURL`.
```
var URL = NSURL(string: "https://github.com/timeline.json")
var cycle = Cycle(requestURL: URL)
```

There are other parameters, such as `parameters`, which will be discussed in the following sections.

To send the HTTP request, call the method `func start(completionHandler: CycleCompletionHandler? = nil)` of `Cycle`.
```
cycle.start(completionHandler: {(cycle, error) in
    // handle response
})
```
You can handle the response in the `completionHandler` closure. Because `completionHandler` is the last parameter, the code can be simplified with Trailing Closures expression.
```
cycle.start {(cycle, error) in
  // handle response
}
```

You can examine the optional parameter `error` to see if the content is fetched successfully. The error can be caused by HTTP connection, Processor objects, HTTP status code, etc. For more information on error handling, see :ref:`error`


.. :ref:`error`

POST raw data
----
You can post raw data through both approaches: 1) the convenient method of `Cycle`. 2) create, configure a `Cycle` object and then "start".

Here is an example of using the convenient method:
```
Cycle.post("http://127.0.0.1:8000/test/dumpupload/",
    requestObject: "Hello World".dataUsingEncoding(NSUTF8StringEncoding),
    requestProcessors: [DataProcessor()],
    completionHandler: {
        (cycle, error) in
        println("\(cycle.response.text)") // Hello World
    })
```

In this code snippet, a NSData is past as parameter `requestObject` and a `DataProcessor` is created and passed as `requestProcessors` in an array. The relationship between `requestObject` and `requestProcessors` will be explained in :ref:send_request_with_processors, :ref:receive_response_with_processors and :ref:the_object_property.

Here is an example of creating the `Cycle` manually. You create the `Cycle` and assign the NSData to the property `data` of the Request, which is property `request` of the `Cycle`.
```
var URL = NSURL(string: "http://127.0.0.1:8000/test/dumpupload/")
var cycle = Cycle(requestURL: URL, requestMethod: "POST")
cycle.request.data = "Hello World".dataUsingEncoding(NSUTF8StringEncoding)
cycle.start {
    (cycle, error) in
    println("\(cycle.response.text)") // Hello World
}
```

.. :ref:`error`
.. :ref:`receive_response_with_processors`
.. :ref:`the_object_property`


  - Cancellation
-----
To cancel a request, you need the `Cycle` object the request attached to. If the request is issued by a convenient method, you need to store the `Cycle` object returned from that convenient method.
```
var cycle = Cycle.get("https://github.com/timeline.json", completionHandler: {
    (cycle, error) in
    // ...
});
```

Call the method `func cancel(explicitly: Bool)` of `Cycle` to cancel the request. The parameter `explicitly` indicates if the request is cancelled explicitly. `explicitly` does not affect how the connection will be cancelled, but merely a value to be stored in the property `explicitlyCanceling` of `Cycle`. Your app can use this value for cancellation logic -- when the connection is cancelled, the `completionHandler` won't be called if `explicitly` is set as `true`. You probably want to pass `true` as `explicitly`, to address the cases that users cancelled an operation explicitly. If you pass `false`, you can examine the argument `error` of `completionHandler` to see if the connection is cancelled, here is an example.
```
cycle.start(completionHandler: {(cycle, error) in
    if let e = error {
        if e.domain == NSURLErrorDomain && e.code == NSURLErrorCancelled {
            // Process cancellation
        }
    }
})
```

  - Add parameters to URL
To add parameters (query) to URL, pass a dictionary as `parameters` to the convenient methods. The code snippet below adds parameter "key1=value1" to the URL -- the URL becomes "http://httpbin.org/get?key1=value1".

```
Cycle.get("http://httpbin.org/get",
        parameters: ["key1": ["value1"]],
        completionHandler: {cycle, error in
            println("\(cycle.response.text)")
    })
```

The type of `parameter` is `Dictionary<String, String[]>`, the type of the key is `String`, the type of the value is an array of `String`. While in most cases, you will use the array to hold one single value, it allow multiple values to be associated with a single key. The final URL produced by the code below is "http://httpbin.org/get?key1=value1&key1=value1a".

```
Cycle.get("http://httpbin.org/get",
        parameters: ["key1": ["value1", "value1a"]],
        completionHandler: {cycle, error in
            println("\(cycle.response.text)")
    })
```

There is no such `parameters` when you create a `Cycle` by yourself. It's very simple to build a URL from the parameters through the helper methods provided by Cycles.

```
// result: http://httpbin.org/get?key1=value1
var URLString = MergeParametersToURL("http://httpbin.org/get", ["key1": ["value1"]])
```

The function `MergeParametersToURL` will correctly encode the values, join the parameter pairs with character `&` and join the original URL with character `?`.  `MergeParametersToURL` also allows query string in the original URL, the method will parse the query and merge them with the parameters. In the code snippet below, `key2` in the original URL and `key1` in the parameter will both appear in the final URL.

```
// result: http://httpbin.org/get?key1=value1&key2=value2
var URLString = MergeParametersToURL("http://httpbin.org/get?key2=value2", ["key1": ["value1"]])
```



----

  - Response content
  - Response status
  - Response error
  - Upload
  - Download
  - Handle JSON response
  - Handle response with processors
  - Send JSON request
  - Send request with processors
  - Receive response with processors
  - The `object` property of Request and Response
  - Auto retry
  - Custom headers
  - Timeout
  - Solicited request
- Advanced
  - The default session
  - Create and use your own session
  - Delegate queues
  - Authentication
  - Restart
  - Tests
